This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-06T08:55:48.834Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.dockerignore
.gitattributes
.gitignore
.mvn/wrapper/maven-wrapper.properties
Dockerfile
mvnw
mvnw.cmd
pom.xml
README.Docker.md
src/main/java/com/backend/system/config/CloudinaryConfig.java
src/main/java/com/backend/system/config/FCMConfig.java
src/main/java/com/backend/system/config/OpenAPIConfig.java
src/main/java/com/backend/system/config/SecurityConfig.java
src/main/java/com/backend/system/config/WebSocketConfig.java
src/main/java/com/backend/system/constant/ModeType.java
src/main/java/com/backend/system/controller/AuthController.java
src/main/java/com/backend/system/controller/HistoryController.java
src/main/java/com/backend/system/controller/NotificationController.java
src/main/java/com/backend/system/controller/PeopleController.java
src/main/java/com/backend/system/controller/PiController.java
src/main/java/com/backend/system/controller/UserController.java
src/main/java/com/backend/system/controller/WarningController.java
src/main/java/com/backend/system/dto/request/AuthRequest.java
src/main/java/com/backend/system/dto/request/HistoryRequest.java
src/main/java/com/backend/system/dto/request/PeopleRequest.java
src/main/java/com/backend/system/dto/request/PiRequest.java
src/main/java/com/backend/system/dto/request/RegistrationTokenRequest.java
src/main/java/com/backend/system/dto/request/UserRequest.java
src/main/java/com/backend/system/dto/request/WarningRequest.java
src/main/java/com/backend/system/dto/response/ApiResponse.java
src/main/java/com/backend/system/dto/response/ErrorResponse.java
src/main/java/com/backend/system/dto/response/HistoryResponse.java
src/main/java/com/backend/system/dto/response/PeopleResponse.java
src/main/java/com/backend/system/dto/response/PiResponse.java
src/main/java/com/backend/system/dto/response/RegistrationTokenResponse.java
src/main/java/com/backend/system/dto/response/TokenResponse.java
src/main/java/com/backend/system/dto/response/UserResponse.java
src/main/java/com/backend/system/dto/response/WarningResponse.java
src/main/java/com/backend/system/entity/BaseEntity.java
src/main/java/com/backend/system/entity/History.java
src/main/java/com/backend/system/entity/NoticeFCM.java
src/main/java/com/backend/system/entity/Notification.java
src/main/java/com/backend/system/entity/People.java
src/main/java/com/backend/system/entity/Pi.java
src/main/java/com/backend/system/entity/User.java
src/main/java/com/backend/system/entity/Warning.java
src/main/java/com/backend/system/exception/AppException.java
src/main/java/com/backend/system/exception/ErrorCode.java
src/main/java/com/backend/system/exception/GlobalExceptionHandler.java
src/main/java/com/backend/system/exception/InvalidTokenException.java
src/main/java/com/backend/system/exception/JwtAccessDeniedHandler.java
src/main/java/com/backend/system/exception/JwtAuthenticationEntrypoint.java
src/main/java/com/backend/system/exception/TokenException.java
src/main/java/com/backend/system/exception/TokenExpiredException.java
src/main/java/com/backend/system/filter/JwtAuthenticationFilter.java
src/main/java/com/backend/system/mapper/HistoryMapper.java
src/main/java/com/backend/system/mapper/PeopleMapper.java
src/main/java/com/backend/system/mapper/PiMapper.java
src/main/java/com/backend/system/mapper/UserMapper.java
src/main/java/com/backend/system/mapper/WarningMapper.java
src/main/java/com/backend/system/repository/HistoryRepository.java
src/main/java/com/backend/system/repository/PeopleRepository.java
src/main/java/com/backend/system/repository/PiRepository.java
src/main/java/com/backend/system/repository/UserRepository.java
src/main/java/com/backend/system/repository/WarningRepository.java
src/main/java/com/backend/system/security/CustomUserDetails.java
src/main/java/com/backend/system/security/CustomUserDetailsService.java
src/main/java/com/backend/system/security/JwtAuthenticationProvider.java
src/main/java/com/backend/system/service/AuthService.java
src/main/java/com/backend/system/service/CloudinaryService.java
src/main/java/com/backend/system/service/FCMService.java
src/main/java/com/backend/system/service/HistoryService.java
src/main/java/com/backend/system/service/impl/AuthServiceImpl.java
src/main/java/com/backend/system/service/impl/CloudinaryServiceImpl.java
src/main/java/com/backend/system/service/impl/FCMServiceImpl.java
src/main/java/com/backend/system/service/impl/HistoryServiceImpl.java
src/main/java/com/backend/system/service/impl/NotificationServiceImpl.java
src/main/java/com/backend/system/service/impl/PeopleServiceImpl.java
src/main/java/com/backend/system/service/impl/PiServiceImpl.java
src/main/java/com/backend/system/service/impl/UserServiceImpl.java
src/main/java/com/backend/system/service/impl/WarningServiceImpl.java
src/main/java/com/backend/system/service/NotificationService.java
src/main/java/com/backend/system/service/PeopleService.java
src/main/java/com/backend/system/service/PiService.java
src/main/java/com/backend/system/service/UserService.java
src/main/java/com/backend/system/service/WarningService.java
src/main/java/com/backend/system/SystemApplication.java
src/main/resources/application.properties
src/main/resources/application.yaml
src/test/java/com/backend/system/RabbitMQTest.java
src/test/java/com/backend/system/SystemApplicationTests.java

================================================================
Repository Files
================================================================

================
File: .dockerignore
================
# Include any files or directories that you don't want to be copied to your
# container here (e.g., local build artifacts, temporary files, etc.).
#
# For more help, visit the .dockerignore file reference guide at
# https://docs.docker.com/go/build-context-dockerignore/

**/.classpath
**/.dockerignore
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/.vscode
**/.next
**/.cache
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/charts
**/docker-compose*
**/compose.y*ml
**/target
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
**/vendor
LICENSE
README.md

================
File: .gitattributes
================
/mvnw text eol=lf
*.cmd text eol=crlf

================
File: .gitignore
================
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

.env
src/main/resources/firebase/firebase-service-account.json
compose.yaml

================
File: .mvn/wrapper/maven-wrapper.properties
================
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

================
File: Dockerfile
================
# syntax=docker/dockerfile:1

# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Dockerfile reference guide at
# https://docs.docker.com/go/dockerfile-reference/

# Want to help us make this template better? Share your feedback here: https://forms.gle/ybq9Krt8jtBL3iCk7

################################################################################

# Create a stage for resolving and downloading dependencies.
FROM eclipse-temurin:17-jdk-jammy AS deps

WORKDIR /build

# Copy the mvnw wrapper with executable permissions.
COPY --chmod=0755 mvnw mvnw
COPY .mvn/ .mvn/

# Download dependencies as a separate step to take advantage of Docker's caching.
# Leverage a cache mount to /root/.m2 so that subsequent builds don't have to
# re-download packages.
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 ./mvnw dependency:go-offline -DskipTests

################################################################################

# Create a stage for building the application based on the stage with downloaded dependencies.
# This Dockerfile is optimized for Java applications that output an uber jar, which includes
# all the dependencies needed to run your app inside a JVM. If your app doesn't output an uber
# jar and instead relies on an application server like Apache Tomcat, you'll need to update this
# stage with the correct filename of your package and update the base image of the "final" stage
# use the relevant app server, e.g., using tomcat (https://hub.docker.com/_/tomcat/) as a base image.
FROM deps AS package

WORKDIR /build

COPY ./src src/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw package -DskipTests && \
    mv target/$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout)-$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout).jar target/app.jar

################################################################################

# Create a stage for extracting the application into separate layers.
# Take advantage of Spring Boot's layer tools and Docker's caching by extracting
# the packaged application into separate layers that can be copied into the final stage.
# See Spring's docs for reference:
# https://docs.spring.io/spring-boot/docs/current/reference/html/container-images.html
FROM package AS extract

WORKDIR /build

RUN java -Djarmode=layertools -jar target/app.jar extract --destination target/extracted

################################################################################

# Create a new stage for running the application that contains the minimal
# runtime dependencies for the application. This often uses a different base
# image from the install or build stage where the necessary files are copied
# from the install stage.
#
# The example below uses eclipse-turmin's JRE image as the foundation for running the app.
# By specifying the "17-jre-jammy" tag, it will also use whatever happens to be the
# most recent version of that tag when you build your Dockerfile.
# If reproducability is important, consider using a specific digest SHA, like
# eclipse-temurin@sha256:99cede493dfd88720b610eb8077c8688d3cca50003d76d1d539b0efc8cca72b4.
FROM eclipse-temurin:17-jre-jammy AS final

# Create a non-privileged user that the app will run under.
# See https://docs.docker.com/go/dockerfile-user-best-practices/
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser
USER appuser

# Copy the executable from the "package" stage.
COPY --from=extract build/target/extracted/dependencies/ ./
COPY --from=extract build/target/extracted/spring-boot-loader/ ./
COPY --from=extract build/target/extracted/snapshot-dependencies/ ./
COPY --from=extract build/target/extracted/application/ ./

EXPOSE 8080

ENTRYPOINT [ "java", "org.springframework.boot.loader.launch.JarLauncher" ]

================
File: mvnw
================
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

================
File: mvnw.cmd
================
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.4.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.backend</groupId>
	<artifactId>system</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>system</name>
	<description>Simulating an Automatic Door Opening/Closing System</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<org.mapstruct.version>1.6.3</org.mapstruct.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.mapstruct</groupId>
			<artifactId>mapstruct</artifactId>
			<version>${org.mapstruct.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>com.cloudinary</groupId>
			<artifactId>cloudinary-http5</artifactId>
			<version>2.0.0</version>
		</dependency>
		<dependency>
			<groupId>com.cloudinary</groupId>
			<artifactId>cloudinary-taglib</artifactId>
			<version>2.0.0</version>
		</dependency>
		<dependency>
			<groupId>io.github.cdimascio</groupId>
			<artifactId>dotenv-java</artifactId>
			<version>2.2.4</version>
		</dependency>
		<dependency>
			<groupId>com.google.firebase</groupId>
			<artifactId>firebase-admin</artifactId>
			<version>9.4.3</version>
		</dependency>
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.8.5</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-websocket</artifactId>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
						<path>
							<groupId>org.mapstruct</groupId>
							<artifactId>mapstruct-processor</artifactId>
							<version>${org.mapstruct.version}</version>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

================
File: README.Docker.md
================
### Building and running your application

When you're ready, start your application by running:
`docker compose up --build`.

Your application will be available at http://localhost:8080.

### Deploying your application to the cloud

First, build your image, e.g.: `docker build -t myapp .`.
If your cloud uses a different CPU architecture than your development
machine (e.g., you are on a Mac M1 and your cloud provider is amd64),
you'll want to build the image for that platform, e.g.:
`docker build --platform=linux/amd64 -t myapp .`.

Then, push it to your registry, e.g. `docker push myregistry.com/myapp`.

Consult Docker's [getting started](https://docs.docker.com/go/get-started-sharing/)
docs for more detail on building and pushing.

================
File: src/main/java/com/backend/system/config/CloudinaryConfig.java
================
package com.backend.system.config;

import com.cloudinary.Cloudinary;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CloudinaryConfig {

    @Value("${CLOUDINARY_URL}")
    private String cloudinaryUrl;

    @Bean
    public Cloudinary cloudinary() {
        return new Cloudinary(cloudinaryUrl);
    }
}

================
File: src/main/java/com/backend/system/config/FCMConfig.java
================
package com.backend.system.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.messaging.FirebaseMessaging;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;

import java.io.IOException;

@Configuration
public class FCMConfig {

    @Value("${firebase.credentials.path}")
    private Resource firebaseCredentials;

    @Bean
    public FirebaseMessaging initializeFireBase() throws IOException {
        GoogleCredentials googleCredentials = GoogleCredentials
                .fromStream(firebaseCredentials.getInputStream());

        FirebaseOptions firebaseOptions = FirebaseOptions
                .builder()
                .setCredentials(googleCredentials)
                .build();

        FirebaseApp firebaseApp = FirebaseApp.initializeApp(firebaseOptions);
        return FirebaseMessaging.getInstance(firebaseApp);
    }
}

================
File: src/main/java/com/backend/system/config/OpenAPIConfig.java
================
package com.backend.system.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Backend API")
                        .version("1.0")
                        .description("API documentation for the backend system"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth",
                                new SecurityScheme()
                                        .name("Authorization")
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")
                        ));
    }
}

================
File: src/main/java/com/backend/system/config/SecurityConfig.java
================
package com.backend.system.config;

import com.backend.system.filter.JwtAuthenticationFilter;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
public class SecurityConfig {

    JwtAuthenticationFilter jwtAuthenticationFilter;
    AuthenticationEntryPoint authenticationEntryPoint;
    AccessDeniedHandler accessDeniedHandler;

    private final String[] PUBLIC_ENDPOINT = {
            "/api/auth/login",
            "/api/auth/register",
            "/v3/api-docs/**",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/ws/**"
    };

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http.csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(authorize ->
                        authorize.requestMatchers(PUBLIC_ENDPOINT).permitAll()
                                .anyRequest().authenticated())
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exception ->
                        exception.authenticationEntryPoint(authenticationEntryPoint)
                                .accessDeniedHandler(accessDeniedHandler)
                )
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration)
            throws Exception {
        return configuration.getAuthenticationManager();
    }
}

================
File: src/main/java/com/backend/system/config/WebSocketConfig.java
================
package com.backend.system.config;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}

================
File: src/main/java/com/backend/system/constant/ModeType.java
================
package com.backend.system.constant;

public enum ModeType {
    SECURE,
    FREE
}

================
File: src/main/java/com/backend/system/controller/AuthController.java
================
package com.backend.system.controller;

import com.backend.system.dto.request.AuthRequest;
import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.TokenResponse;
import com.backend.system.dto.response.UserResponse;
import com.backend.system.service.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Auth Controller", description = "Controller gồm các API quản lý liên quan tới xác thực")
public class AuthController {
    AuthService authService;

    @Operation(
            description = "API đăng nhập hệ thống. Xác thực admin và trả về JWT token."
    )
    @PostMapping("/login")
    public ResponseEntity<ApiResponse<TokenResponse>> login(@Valid @RequestBody AuthRequest authRequest) {
        log.info("Login request for user: {}", authRequest.getUsername());
        return ResponseEntity.ok(
                ApiResponse.<TokenResponse>builder()
                        .success(true)
                        .message("Login successfully")
                        .data(authService.login(authRequest))
                        .build()
        );
    }

    @Operation(
            description = "API đăng ký tài khoản mới. Tạo tài khoản admin trong hệ thống."
    )
    @PostMapping("/register")
    public ResponseEntity<ApiResponse<Void>> register(@Valid @RequestBody AuthRequest authRequest) {
        log.info("Register request for user: {}", authRequest.getUsername());
        authService.register(authRequest);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("Registration successfully")
                        .data(null)
                        .build()
        );
    }

    @Operation(
            description = "API lấy thông tin admin hiện tại dựa trên JWT token."
    )
    @GetMapping("/me")
    public ResponseEntity<ApiResponse<UserResponse>> getMe(@AuthenticationPrincipal UserDetails userDetails) {
        log.info("Fetching current user information");
        return ResponseEntity.ok(
                ApiResponse.<UserResponse>builder()
                        .success(true)
                        .message("Fetching current user information successfully")
                        .data(authService.getMe(userDetails))
                        .build()
        );
    }

    @Operation(
            description = "API lấy thông tin registration token của admin hiện tại."
    )
    @GetMapping("/me/token")
    public ResponseEntity<ApiResponse<String>> getToken(@AuthenticationPrincipal UserDetails userDetails) {
        log.info("Fetching current user token");
        return ResponseEntity.ok(
                ApiResponse.<String>builder()
                        .success(true)
                        .message("Fetching current user token successfully")
                        .data(authService.getRegistrationToken(userDetails))
                        .build()
        );
    }

    @Operation(
            description = "API cập nhật registration token của người dùng hiện tại."
    )
    @PutMapping("/me/token")
    public ResponseEntity<ApiResponse<Void>> updateToken(
            @AuthenticationPrincipal UserDetails userDetails,
            @Valid @RequestBody RegistrationTokenRequest registrationTokenRequest) {
        log.info("Updating current user token");
        authService.updateRegistrationToken(userDetails, registrationTokenRequest);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("Updating current user token successfully")
                        .data(null)
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/controller/HistoryController.java
================
package com.backend.system.controller;

import com.backend.system.dto.request.HistoryRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.HistoryResponse;
import com.backend.system.service.HistoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;

@RestController
@RequestMapping("/api/history")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
@Tag(name = "History Controller", description = "Controller gồm các API quản lý history")
public class HistoryController {
    HistoryService historyService;

    @Operation(
            description = "API lấy danh sách tất cả history trong hệ thống với phân trang và lọc theo thời gian."
    )
    @GetMapping("")
    public ResponseEntity<ApiResponse<Page<HistoryResponse>>> getAll(
        @RequestParam(name = "page", defaultValue = "0") int page,
        @RequestParam(name = "limit", defaultValue = "20") int limit,
        @RequestParam(name = "start", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate start,
        @RequestParam(name = "end", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate end
    ) {
        log.info("Fetching all histories");
        Page<HistoryResponse> historyResponses = historyService.getAll(page, limit, start, end);
        return ResponseEntity.ok(ApiResponse.<Page<HistoryResponse>>builder()
                .success(true)
                .message("Fetching all histories successfully")
                .data(historyResponses)
                .build());
    }

    @Operation(
            description = "API thêm mới lịch sử vào hệ thống."
    )
    @PostMapping("")
    public ResponseEntity<ApiResponse<HistoryResponse>> addHistory(
            @Valid @RequestBody HistoryRequest historyRequest
    ) {
        log.info("Adding new history");
        return ResponseEntity.ok(ApiResponse.<HistoryResponse>builder()
                .success(true)
                .message("History added successfully")
                .data(historyService.addHistory(historyRequest))
                .build());
    }

    @Operation(
            description = "API lấy thông tin lịch sử theo ID."
    )
    @GetMapping("/{historyId}")
    public ResponseEntity<ApiResponse<HistoryResponse>> getHistoryById(
            @PathVariable("historyId") Long historyId
    ) {
        log.info("Fetching history with ID: {}", historyId);
        return ResponseEntity.ok(ApiResponse.<HistoryResponse>builder()
                .success(true)
                .message("History fetched successfully")
                .data(historyService.getHistoryById(historyId))
                .build());
    }

    @Operation(
            description = "API cập nhật thông tin lịch sử theo ID."
    )
    @PutMapping("/{historyId}")
    public ResponseEntity<ApiResponse<HistoryResponse>> updateHistoryById(
            @PathVariable("historyId") Long historyId,
            @Valid @RequestBody HistoryRequest historyRequest
    ) {
        log.info("Updating history with ID: {}", historyId);
        return ResponseEntity.ok(ApiResponse.<HistoryResponse>builder()
                .success(true)
                .message("History updated successfully")
                .data(historyService.updateHistoryById(historyId, historyRequest))
                .build());
    }

    @Operation(
            description = "API xóa lịch sử theo ID."
    )
    @DeleteMapping("/{historyId}")
    public ResponseEntity<ApiResponse<Void>> deleteHistoryById(
            @PathVariable("historyId") Long historyId
    ) {
        log.info("Deleting history with ID: {}", historyId);
        historyService.deleteHistoryById(historyId);
        return ResponseEntity.ok(ApiResponse.<Void>builder()
                .success(true)
                .message("History deleted successfully")
                .build()
        );
    }

    @Operation(
            description = "API lấy danh sách lịch sử theo ID người dùng với phân trang."
    )
    @GetMapping("/pepple/{peopleId}")
    public ResponseEntity<ApiResponse<Page<HistoryResponse>>> getHistoriesByPeopleId(
            @PathVariable("peopleId") Long peopleId,
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "limit", defaultValue = "20") int limit
    ) {
        log.info("Fetching histories by people ID: {}", peopleId);
        return ResponseEntity.ok(
                ApiResponse.<Page<HistoryResponse>>builder()
                        .success(true)
                        .message("Fetching histories by people ID: " + peopleId + " successfully")
                        .data(historyService.getHistoriesByPeopleId(peopleId, page, limit))
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/controller/NotificationController.java
================
package com.backend.system.controller;

import com.backend.system.service.NotificationService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/notification")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class NotificationController {

    NotificationService notificationService;

}

================
File: src/main/java/com/backend/system/controller/PeopleController.java
================
package com.backend.system.controller;

import com.backend.system.dto.request.PeopleRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.PeopleResponse;

import com.backend.system.service.PeopleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/people")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
@Tag(name = "People Controller", description = " Controller gồm các API quản lý People")
public class PeopleController {
    PeopleService peopleService;

    @Operation(
            description = "API lấy danh sách tất cả người dùng trong hệ thống với phân trang."
    )
    @GetMapping("")
    public ResponseEntity<ApiResponse<Page<PeopleResponse>>> getAll(
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "limit", defaultValue = "20") int limit
    ) {
        log.info("Fetching all people");
        return ResponseEntity.ok(
                ApiResponse.<Page<PeopleResponse>>builder()
                        .success(true)
                        .message("Fetching all people successfully")
                        .data(peopleService.getAll(page, limit))
                        .build()
        );
    }

    @Operation(
            description = "API thêm người dùng mới vào hệ thống."
    )
    @PostMapping("")
    public ResponseEntity<ApiResponse<PeopleResponse>> addPeople(
            @Valid @ModelAttribute PeopleRequest peopleRequest
    ) {
        log.info("Adding new people");
        return ResponseEntity.ok(
                ApiResponse.<PeopleResponse>builder()
                        .success(true)
                        .message("People added successfully")
                        .data(peopleService.addPeople(peopleRequest))
                        .build()
        );
    }

    @Operation(
            description = "API lấy thông tin người dùng theo ID."
    )
    @GetMapping("/{peopleId}")
    public ResponseEntity<ApiResponse<PeopleResponse>> getPeopleById(
            @PathVariable("peopleId") Long peopleId) {
        log.info("Fetching people with ID: {}", peopleId);
        return ResponseEntity.ok(
                ApiResponse.<PeopleResponse>builder()
                        .success(true)
                        .message("People fetched successfully")
                        .data(peopleService.getPeopleDtoById(peopleId))
                        .build()
        );
    }

    @Operation(
            description = "API cập nhật thông tin người dùng theo ID."
    )
    @PutMapping("/{peopleId}")
    public ResponseEntity<ApiResponse<PeopleResponse>> updatePeopleById(
            @PathVariable("peopleId") Long peopleId,
            @Valid @ModelAttribute PeopleRequest peopleRequest) {
        log.info("Updating people with ID: {}", peopleId);
        return ResponseEntity.ok(
                ApiResponse.<PeopleResponse>builder()
                        .success(true)
                        .message("People updated successfully")
                        .data(peopleService.updatePeopleById(peopleId, peopleRequest))
                        .build()
        );
    }

    @Operation(
            description = "API xóa người dùng theo ID."
    )
    @DeleteMapping("/{peopleId}")
    public ResponseEntity<ApiResponse<Void>> deletePeopleById(@PathVariable("peopleId") Long peopleId) {
        log.info("Deleting people with ID: {}", peopleId);
        peopleService.deletePeopleById(peopleId);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("People deleted successfully")
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/controller/PiController.java
================
package com.backend.system.controller;

import com.backend.system.constant.ModeType;
import com.backend.system.dto.request.PiRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.PiResponse;
import com.backend.system.service.PiService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/pi")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
public class PiController {

    PiService piService;

    @GetMapping("")
    public ResponseEntity<ApiResponse<List<PiResponse>>> getAll() {
        log.info("Fetching all Pi");
        return ResponseEntity.ok(
                ApiResponse.<List<PiResponse>>builder()
                        .success(true)
                        .message("Fetching all Pi successfully")
                        .data(piService.getAll())
                        .build()
        );
    }

    @GetMapping("/{piId}")
    public ResponseEntity<ApiResponse<PiResponse>> getPiById(@PathVariable("piId") Long piId) {
        log.info("Fetching Pi with ID: {}", piId);
        return ResponseEntity.ok(
                ApiResponse.<PiResponse>builder()
                        .success(true)
                        .message("Fetching Pi successfully")
                        .data(piService.getPiById(piId))
                        .build()
        );
    }

    @PostMapping("")
    public ResponseEntity<ApiResponse<PiResponse>> addPi(@RequestBody PiRequest piRequest) {
        log.info("Adding new Pi");
        return ResponseEntity.ok(
                ApiResponse.<PiResponse>builder()
                        .success(true)
                        .message("Pi added successfully")
                        .data(piService.addPi(piRequest))
                        .build()
        );
    }

    @PutMapping("/{piId}")
    public ResponseEntity<ApiResponse<PiResponse>> updatePiById(
            @PathVariable("piId") Long piId,
            @RequestBody PiRequest piRequest
    ) {
        log.info("Updating Pi with ID: {}", piId);
        return ResponseEntity.ok(
                ApiResponse.<PiResponse>builder()
                        .success(true)
                        .message("Pi updated successfully")
                        .data(piService.updatePiById(piId, piRequest))
                        .build()
        );
    }

    @PutMapping("/{piId}/mode")
    public ResponseEntity<ApiResponse<PiResponse>> updateMode(
            @PathVariable("piId") Long piId,
            @RequestParam("mode") ModeType mode
    ) {
        log.info("Updating Pi with ID: {} to mode: {}", piId, mode.toString());
        return ResponseEntity.ok(
                ApiResponse.<PiResponse>builder()
                        .success(true)
                        .message("Pi mode updated successfully")
                        .data(piService.updateMode(piId, mode))
                        .build()
        );
    }

    @DeleteMapping("/{piId}")
    public ResponseEntity<ApiResponse<Void>> deletePiById(@PathVariable("piId") Long piId) {
        log.info("Deleting Pi with ID: {}", piId);
        piService.deletePiById(piId);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("Pi deleted successfully")
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/controller/UserController.java
================
package com.backend.system.controller;

import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.request.UserRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.RegistrationTokenResponse;
import com.backend.system.dto.response.UserResponse;
import com.backend.system.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/user")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
@Tag(name = "User Controller", description = "Controller gồm các API quản lý User")
public class UserController {
    UserService userService;

    @Operation(
            description = "API lấy danh sách tất cả admin trong hệ thống."
    )
    @GetMapping("")
    public ResponseEntity<ApiResponse<List<UserResponse>>> getAll() {
        log.info("Fetching all users");
        return ResponseEntity.ok(
                ApiResponse.<List<UserResponse>>builder()
                        .success(true)
                        .message("Fetching all users successfully")
                        .data(userService.getAll())
                        .build()
        );
    }

    @Operation(
            description = "API thêm mới admin vào hệ thống."
    )
    @PostMapping("")
    public ResponseEntity<ApiResponse<UserResponse>> addUser(
            @Valid @RequestBody UserRequest userRequest
    ) {
        log.info("Adding new  user");
        return ResponseEntity.ok(
                ApiResponse.<UserResponse>builder()
                        .success(true)
                        .message("User added successfully")
                        .data(userService.addUser((userRequest)))
                        .build()
        );
    }

    @Operation(
            description = "API lấy thông tin admin theo ID."
    )
    @GetMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable("userId") Long userId) {
        log.info("Fetching user with ID: {}", userId);
        return ResponseEntity.ok(
                ApiResponse.<UserResponse>builder()
                        .success(true)
                        .message("User fetched successfully")
                        .data(userService.getUserById(userId))
                        .build()
        );
    }

    @Operation(
            description = "API cập nhật thông tin admin theo ID."
    )
    @PutMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserById(
            @PathVariable("userId") Long userId,
            @Valid @RequestBody UserRequest userRequest) {
        log.info("Update user with ID: {}", userId);
        return ResponseEntity.ok(
                ApiResponse.<UserResponse>builder()
                        .success(true)
                        .message("User updated successfully")
                        .data(userService.updateUserById(userId, userRequest))
                        .build()
        );
    }

    @Operation(
            description = "API xóa admin theo ID."
    )
    @DeleteMapping("/{userId}")
    public ResponseEntity<ApiResponse<Void>> deleteUserById(@PathVariable("userId") Long userId) {
        log.info("Delete user with ID: {}", userId);
        userService.deleteUserById(userId);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("User deleted successfully")
                        .build()
        );
    }

    @Operation(
            description = "API lấy danh sách tất cả registration token trong hệ thống."
    )
    @GetMapping("/token")
    public ResponseEntity<ApiResponse<List<RegistrationTokenResponse>>> getToken() {
        log.info("Fetching all tokens");
        return ResponseEntity.ok(
                ApiResponse.<List<RegistrationTokenResponse>>builder()
                        .success(true)
                        .message("Fetching all tokens successfully")
                        .data(userService.getAllRegistrationTokens())
                        .build()
        );
    }

    @Operation(
            description = "API lấy registration token của admin theo ID."
    )
    @GetMapping("/{userId}/token")
    public ResponseEntity<ApiResponse<RegistrationTokenResponse>> getTokenByUserId(@PathVariable("userId") Long userId) {
        log.info("Fetching token for user with ID: {}", userId);
        return ResponseEntity.ok(
                ApiResponse.<RegistrationTokenResponse>builder()
                        .success(true)
                        .message("Fetching token successfully")
                        .data(userService.getRegistrationTokenByUserId(userId))
                        .build()
        );
    }

    @Operation(
            description = "API cập nhật registration token của admin theo ID."
    )
    @PutMapping("/{userId}/token")
    public ResponseEntity<ApiResponse<Void>> updateTokenByUserId(
            @PathVariable("userId") Long userId,
            @Valid @RequestBody RegistrationTokenRequest registrationTokenRequest
            ) {
        log.info("Updating token for user with ID: {}", userId);
        userService.updateRegistrationTokenByUserId(userId, registrationTokenRequest);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("Token updated successfully")
                        .data(null)
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/controller/WarningController.java
================
package com.backend.system.controller;

import com.backend.system.dto.request.WarningRequest;
import com.backend.system.dto.response.ApiResponse;
import com.backend.system.dto.response.WarningResponse;
import com.backend.system.service.WarningService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;

@RestController
@RequestMapping("/api/warning")
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Warning Controller", description = "Controller gồm các API quản lý Warning")
public class WarningController {

    WarningService warningService;

    @Operation(
            description = "API lấy danh sách tất cả warning trong hệ thống với phân trang và lọc theo thời gian."
    )
    @GetMapping("")
    public ResponseEntity<ApiResponse<Page<WarningResponse>>> getAll(
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "limit", defaultValue = "20") int limit,
            @RequestParam(name = "start", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate start,
            @RequestParam(name = "end", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate end
            ) {
        log.info("Fetching all warnings");
        return ResponseEntity.ok(
                ApiResponse.<Page<WarningResponse>>builder()
                        .success(true)
                        .message("Fetched all warnings successfully")
                        .data(warningService.getAll(page, limit, start, end))
                        .build()
        );
    }

    @Operation(
            description = "API thêm mới warning vào hệ thống."
    )
    @PostMapping("")
    public ResponseEntity<ApiResponse<WarningResponse>> addWarning(
            @Valid @RequestBody WarningRequest warningRequest
            ) {
        log.info("Adding new warning");
        return ResponseEntity.ok(
                ApiResponse.<WarningResponse>builder()
                        .success(true)
                        .message("Warning added successfully")
                        .data(warningService.addWarning(warningRequest))
                        .build()
        );
    }

    @Operation(
            description = "API lấy thông tin warning theo ID."
    )
    @GetMapping("/{warningId}")
    public ResponseEntity<ApiResponse<WarningResponse>> getWarningById(
            @PathVariable("warningId") Long warningId
    ) {
        log.info("Fetching warning with ID: {}", warningId);
        return ResponseEntity.ok(
                ApiResponse.<WarningResponse>builder()
                        .success(true)
                        .message("Warning fetched successfully")
                        .data(warningService.getWarningById(warningId))
                        .build()
        );
    }

    @Operation(
            description = "API cập nhật thông tin warning theo ID."
    )
    @PutMapping("/{warningId}")
    public ResponseEntity<ApiResponse<WarningResponse>> updateWarningById(
            @PathVariable("warningId") Long warningId,
            @Valid @RequestBody WarningRequest warningRequest
    ) {
        log.info("Updating warning with ID: {}", warningId);
        return ResponseEntity.ok(
                ApiResponse.<WarningResponse>builder()
                        .success(true)
                        .message("Warning updated successfully")
                        .data(warningService.updateWarningById(warningId, warningRequest))
                        .build()
        );
    }

    @Operation(
            description = "API xóa warning theo ID."
    )
    @DeleteMapping("/{warningId}")
    public ResponseEntity<ApiResponse<Void>> deleteWarningById(
            @PathVariable("warningId") Long warningId
    ) {
        log.info("Deleting warning with ID: {}", warningId);
        warningService.deleteWarningById(warningId);
        return ResponseEntity.ok(
                ApiResponse.<Void>builder()
                        .success(true)
                        .message("Warning deleted successfully")
                        .build()
        );
    }
}

================
File: src/main/java/com/backend/system/dto/request/AuthRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class AuthRequest {

    @NotBlank
    String username;

    @Pattern(
            regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$",
            message = "Password must contain at least 8 characters, one uppercase letter, one lowercase letter, one number and one special character")
    String password;
}

================
File: src/main/java/com/backend/system/dto/request/HistoryRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
@ToString
public class HistoryRequest {

    @NotNull
    LocalDateTime timestamp;

    Long peopleId;

    String imagePath;

    @NotBlank
    String mode;
}

================
File: src/main/java/com/backend/system/dto/request/PeopleRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotBlank;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.springframework.web.multipart.MultipartFile;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class PeopleRequest {

    @NotBlank(message = "Name is required")
    String name;
    int age;
    MultipartFile file;
}

================
File: src/main/java/com/backend/system/dto/request/PiRequest.java
================
package com.backend.system.dto.request;

import com.backend.system.constant.ModeType;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class PiRequest {

    String description;

    @NotNull(message = "Mode type cannot be null")
    ModeType mode;
}

================
File: src/main/java/com/backend/system/dto/request/RegistrationTokenRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotBlank;
import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class RegistrationTokenRequest {
    @NotBlank
    String token;
}

================
File: src/main/java/com/backend/system/dto/request/UserRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserRequest {

    @NotBlank(message = "Username is required")
    String username;

    @NotBlank
    @Pattern(
            regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$",
            message = "Password must contain at least 8 characters, one uppercase letter, one lowercase letter, one number and one special character")
    String password;

    Long peopleId;
}

================
File: src/main/java/com/backend/system/dto/request/WarningRequest.java
================
package com.backend.system.dto.request;

import jakarta.validation.constraints.NotNull;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class WarningRequest {

    @NotNull
    LocalDateTime timestamp;

    String imagePath;

    String info;
}

================
File: src/main/java/com/backend/system/dto/response/ApiResponse.java
================
package com.backend.system.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Builder
@Setter
@Getter
@FieldDefaults(level = AccessLevel.PRIVATE)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {
    boolean success;
    String message;
    T data;
}

================
File: src/main/java/com/backend/system/dto/response/ErrorResponse.java
================
package com.backend.system.dto.response;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;
import java.util.Map;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
@Builder
public class ErrorResponse {
    int status;
    String errorCode;
    String message;
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    LocalDateTime timestamp;
    String path;
    Map<String, String> errors;
}

================
File: src/main/java/com/backend/system/dto/response/HistoryResponse.java
================
package com.backend.system.dto.response;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class HistoryResponse {
    Long historyId;
    @JsonFormat(pattern = "yyyy-MM-dd HH-mm-ss")
    LocalDateTime timestamp;
    PeopleResponse people;
    String imagePath;
    String mode;
}

================
File: src/main/java/com/backend/system/dto/response/PeopleResponse.java
================
package com.backend.system.dto.response;

import lombok.*;
import lombok.experimental.FieldDefaults;

@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class PeopleResponse {
    Long peopleId;
    String name;
    int age;
    String faceImagePath;
}

================
File: src/main/java/com/backend/system/dto/response/PiResponse.java
================
package com.backend.system.dto.response;

import com.backend.system.constant.ModeType;
import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class PiResponse {

    Long piId;
    String description;
    ModeType mode;
}

================
File: src/main/java/com/backend/system/dto/response/RegistrationTokenResponse.java
================
package com.backend.system.dto.response;

import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class RegistrationTokenResponse {
    String token;
}

================
File: src/main/java/com/backend/system/dto/response/TokenResponse.java
================
package com.backend.system.dto.response;

import lombok.*;
import lombok.experimental.FieldDefaults;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class TokenResponse {
    String token;
    String tokenType;
    long expiration;
}

================
File: src/main/java/com/backend/system/dto/response/UserResponse.java
================
package com.backend.system.dto.response;

import lombok.*;
import lombok.experimental.FieldDefaults;

@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserResponse {
    Long userId;
    String username;
    PeopleResponse people;
}

================
File: src/main/java/com/backend/system/dto/response/WarningResponse.java
================
package com.backend.system.dto.response;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@FieldDefaults(level = AccessLevel.PRIVATE)
public class WarningResponse {

    @JsonFormat(pattern = "yyyy-MM-dd HH-mm-ss")
    LocalDateTime timestamp;
    String imagePath;
    String info;
}

================
File: src/main/java/com/backend/system/entity/BaseEntity.java
================
package com.backend.system.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Getter
@Setter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@FieldDefaults(level = AccessLevel.PRIVATE)
public class BaseEntity {

    @Column(name = "created_at", updatable = false)
    @CreatedDate
    LocalDateTime createdAt;

    @Column(name = "updated_at")
    @LastModifiedDate
    LocalDateTime updatedAt;
}

================
File: src/main/java/com/backend/system/entity/History.java
================
package com.backend.system.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "histories", indexes = {
        @Index(name = "idx_timestamp", columnList = "timestamp"),
        @Index(name = "idx_people_id", columnList = "people_id")
})
@FieldDefaults(level = AccessLevel.PRIVATE)
public class History extends BaseEntity{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long historyId;

    @Column(nullable = false)
    LocalDateTime timestamp;

    @ManyToOne
    @JoinColumn(name = "people_id", referencedColumnName = "people_id")
    People people;

    String imagePath;

    String mode;
}

================
File: src/main/java/com/backend/system/entity/NoticeFCM.java
================
package com.backend.system.entity;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.util.List;
import java.util.Map;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class NoticeFCM implements Serializable {
    private String subject;
    private String content;
    private String imagePath;
    private Map<String, String> data;
    private List<String> registrationTokens;
}

================
File: src/main/java/com/backend/system/entity/Notification.java
================
package com.backend.system.entity;

import lombok.*;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class Notification <T>{
    private String message;
    T data;
}

================
File: src/main/java/com/backend/system/entity/People.java
================
package com.backend.system.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "people")
public class People extends BaseEntity{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "people_id")
    Long peopleId;

    @Column(nullable = false)
    String name;

    int age;

    @Column(name = "face_image_path")
    String faceImagePath;

    @OneToMany(mappedBy = "people", orphanRemoval = true)
    Set<History> histories = new HashSet<>();
}

================
File: src/main/java/com/backend/system/entity/Pi.java
================
package com.backend.system.entity;

import com.backend.system.constant.ModeType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "pi")
public class Pi extends BaseEntity{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long piId;

    private String description;

    @Column(nullable = false)
    @Enumerated(value = EnumType.STRING)
    private ModeType mode;
}

================
File: src/main/java/com/backend/system/entity/User.java
================
package com.backend.system.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "users")
public class User extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long userId;

    @Column(unique = true, nullable = false)
    String username;

    @Column(nullable = false)
    String password;

    @OneToOne
    @JoinColumn(name = "people_id", referencedColumnName = "people_id", unique = true)
    People people;

    String registrationToken;
}

================
File: src/main/java/com/backend/system/entity/Warning.java
================
package com.backend.system.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;

import java.time.LocalDateTime;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "warnings", indexes = {
        @Index(name = "idx_timestamp", columnList = "timestamp")
})
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Warning extends BaseEntity{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long warningId;

    @Column(nullable = false)
    LocalDateTime timestamp;

    String imagePath;

    String info;
}

================
File: src/main/java/com/backend/system/exception/AppException.java
================
package com.backend.system.exception;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class AppException extends RuntimeException{
    private ErrorCode errorCode;

    public AppException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

================
File: src/main/java/com/backend/system/exception/ErrorCode.java
================
package com.backend.system.exception;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.experimental.FieldDefaults;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

@AllArgsConstructor
@Getter
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public enum ErrorCode {

    PEOPLE_NOT_FOUND(404, "People not found", HttpStatus.NOT_FOUND),
    PEOPLE_ALREADY_EXISTS(409, "People already exists", HttpStatus.CONFLICT),
    USER_NOT_FOUND(404, "User not found", HttpStatus.NOT_FOUND),
    USERNAME_ALREADY_EXISTS(409, "Username already exists", HttpStatus.CONFLICT),
    HISTORY_NOT_FOUND(404, "History not found", HttpStatus.NOT_FOUND),
    WARNING_NOT_FOUND(404, "Warning not found", HttpStatus.NOT_FOUND),
    PI_NOT_FOUND(404, "Pi not found", HttpStatus.NOT_FOUND),
    AUTHENTICATION_FAILED(401, "Authentication failed", HttpStatus.UNAUTHORIZED),
    FORBIDDEN(403, "Forbidden - You do not have permission to access this resource", HttpStatus.FORBIDDEN),
    UNAUTHORIZED(401, "Unauthorized - You need to log in to access this resource", HttpStatus.UNAUTHORIZED),
    INVALID_TOKEN(401, "The provided token is invalid", HttpStatus.UNAUTHORIZED),
    TOKEN_EXPIRED(401, "The token has expired", HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(401, "Invalid credentials", HttpStatus.UNAUTHORIZED),
    INTERNAL_SERVER_ERROR(500, "Internal server error", HttpStatus.INTERNAL_SERVER_ERROR),
    IMAGE_UPLOAD_ERROR(500, "Error uploading image", HttpStatus.INTERNAL_SERVER_ERROR);
    int code;
    String message;
    HttpStatusCode httpStatusCode;
}

================
File: src/main/java/com/backend/system/exception/GlobalExceptionHandler.java
================
package com.backend.system.exception;

import com.backend.system.dto.response.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception e,
                                                                HttpServletRequest request) {
        log.error("General Exception: {}", e.getMessage());
        return new ResponseEntity<>(
                ErrorResponse.builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .errorCode(HttpStatus.BAD_REQUEST.toString())
                        .message(e.getMessage())
                        .timestamp(LocalDateTime.now())
                        .path(request.getRequestURI())
                        .build(),
                HttpStatus.INTERNAL_SERVER_ERROR
        );
    }

    @ExceptionHandler(value = AppException.class)
    public ResponseEntity<ErrorResponse> handleAppException(AppException e,
                                                            HttpServletRequest request) {
        log.error("AppException: {}", e.getMessage());
        ErrorCode errorCode = e.getErrorCode();
        return new ResponseEntity<>(
                ErrorResponse.builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .errorCode(HttpStatus.BAD_REQUEST.toString())
                        .message(errorCode.getMessage())
                        .timestamp(LocalDateTime.now())
                        .path(request.getRequestURI())
                        .build(),
                errorCode.getHttpStatusCode()
        );
    }

    @ExceptionHandler(value = TokenException.class)
    public ResponseEntity<ErrorResponse> handleTokenException(TokenException e,
                                                              HttpServletRequest request) {
        log.error("TokenException: {}", e.getMessage());
        ErrorCode errorCode = e.getErrorCode();
        return new ResponseEntity<>(
                ErrorResponse.builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .errorCode(HttpStatus.BAD_REQUEST.toString())
                        .message(errorCode.getMessage())
                        .timestamp(LocalDateTime.now())
                        .path(request.getRequestURI())
                        .build(),
                errorCode.getHttpStatusCode()
        );
    }

    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException e,
            HttpServletRequest request
    ) {
        Map<String, String> errors = new HashMap<>();
        e.getBindingResult()
                .getFieldErrors()
                .forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
        return new ResponseEntity<>(
                ErrorResponse.builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .errorCode(HttpStatus.BAD_REQUEST.toString())
                        .message("Validation failed")
                        .timestamp(LocalDateTime.now())
                        .path(request.getRequestURI())
                        .errors(errors)
                        .build(),
                e.getStatusCode()
        );
    }
}

================
File: src/main/java/com/backend/system/exception/InvalidTokenException.java
================
package com.backend.system.exception;

public class InvalidTokenException extends TokenException{
    public InvalidTokenException(ErrorCode errorCode) {
        super(errorCode);
    }
}

================
File: src/main/java/com/backend/system/exception/JwtAccessDeniedHandler.java
================
package com.backend.system.exception;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType("application/json");
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("success", false);
        errorResponse.put("message", accessDeniedException.getMessage());

        String json = new ObjectMapper().writeValueAsString(errorResponse);
        response.getWriter().write(json);

    }
}

================
File: src/main/java/com/backend/system/exception/JwtAuthenticationEntrypoint.java
================
package com.backend.system.exception;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtAuthenticationEntrypoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("success", false);
        errorResponse.put("message", authException.getMessage());

        String json = new ObjectMapper().writeValueAsString(errorResponse);
        response.getWriter().write(json);
    }
}

================
File: src/main/java/com/backend/system/exception/TokenException.java
================
package com.backend.system.exception;

public class TokenException extends AppException{
    public TokenException(ErrorCode errorCode) {
        super(errorCode);
    }
}

================
File: src/main/java/com/backend/system/exception/TokenExpiredException.java
================
package com.backend.system.exception;

public class TokenExpiredException extends TokenException{
    public TokenExpiredException(ErrorCode errorCode) {
        super(errorCode);
    }
}

================
File: src/main/java/com/backend/system/filter/JwtAuthenticationFilter.java
================
package com.backend.system.filter;

import com.backend.system.exception.ErrorCode;
import com.backend.system.exception.InvalidTokenException;
import com.backend.system.exception.TokenException;
import com.backend.system.security.JwtAuthenticationProvider;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.servlet.HandlerExceptionResolver;

import java.io.IOException;

@Component
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    JwtAuthenticationProvider jwtAuthenticationProvider;
    UserDetailsService userDetailsService;
    HandlerExceptionResolver handlerExceptionResolver;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        log.info("Processing request: {} {}", request.getMethod(), request.getRequestURI());
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.contains("Bearer")) {
            log.info("Request does not contain Authorization header");
            filterChain.doFilter(request, response);
            return;
        }

        try {
            log.info("Request contains Authorization header");
            String token = authHeader.substring(7);
            String username = jwtAuthenticationProvider.extractUserName(token);
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

            if (username != null && authentication == null) {
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                if (jwtAuthenticationProvider.isTokenValid(token, userDetails)) {
                    log.info("Token is valid for user: {}", username);
                    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities()
                    );
                    authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);
                } else {
                    log.warn("Token is invalid for user: {}", username);
                    throw new InvalidTokenException(ErrorCode.INVALID_TOKEN);
                }
            }
            filterChain.doFilter(request, response);
        } catch (TokenException e) {
            log.error("Error processing JWT token: {}", e.getMessage());
            handlerExceptionResolver.resolveException(request, response, null, e);
        }
    }

}

================
File: src/main/java/com/backend/system/mapper/HistoryMapper.java
================
package com.backend.system.mapper;

import com.backend.system.dto.response.HistoryResponse;
import com.backend.system.entity.History;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring", uses = {PeopleMapper.class})
public interface HistoryMapper {
    HistoryResponse toHistoryResponse(History history);
}

================
File: src/main/java/com/backend/system/mapper/PeopleMapper.java
================
package com.backend.system.mapper;

import com.backend.system.dto.response.PeopleResponse;
import com.backend.system.entity.People;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface PeopleMapper {
    PeopleResponse toPeopleResponse(People people);
}

================
File: src/main/java/com/backend/system/mapper/PiMapper.java
================
package com.backend.system.mapper;

import com.backend.system.dto.response.PiResponse;
import com.backend.system.entity.Pi;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface PiMapper {
    PiResponse convertToPiResponse(Pi pi);
}

================
File: src/main/java/com/backend/system/mapper/UserMapper.java
================
package com.backend.system.mapper;

import com.backend.system.dto.response.UserResponse;
import com.backend.system.entity.User;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring", uses = {PeopleMapper.class})
public interface UserMapper {
    UserResponse toUserResponse(User user);
}

================
File: src/main/java/com/backend/system/mapper/WarningMapper.java
================
package com.backend.system.mapper;

import com.backend.system.dto.response.WarningResponse;
import com.backend.system.entity.Warning;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface WarningMapper {
    WarningResponse covertToWarningResponse(Warning warning);
}

================
File: src/main/java/com/backend/system/repository/HistoryRepository.java
================
package com.backend.system.repository;

import com.backend.system.entity.History;
import com.backend.system.entity.People;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;

public interface HistoryRepository extends JpaRepository<History, Long> {
    Page<History> findAllByTimestampAfterAndTimestampBefore(LocalDateTime timestampAfter, LocalDateTime timestampBefore, Pageable pageable);

    Page<History> findAllByPeople(People people, Pageable pageable);
}

================
File: src/main/java/com/backend/system/repository/PeopleRepository.java
================
package com.backend.system.repository;

import com.backend.system.entity.People;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PeopleRepository extends JpaRepository<People, Long> {
}

================
File: src/main/java/com/backend/system/repository/PiRepository.java
================
package com.backend.system.repository;

import com.backend.system.entity.Pi;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PiRepository extends JpaRepository<Pi, Long> {
}

================
File: src/main/java/com/backend/system/repository/UserRepository.java
================
package com.backend.system.repository;

import com.backend.system.entity.People;
import com.backend.system.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findUserByUsername(String username);
    boolean existsUserByPeople(People people);

    @Query(value = "select u.registrationToken from User u")
    List<String> findAllRegistrationToken();
}

================
File: src/main/java/com/backend/system/repository/WarningRepository.java
================
package com.backend.system.repository;

import com.backend.system.entity.Warning;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import java.time.LocalDateTime;

public interface WarningRepository extends JpaRepository<Warning, Long> {
    Page<Warning> findAllByTimestampAfterAndTimestampBefore(LocalDateTime timestampAfter, LocalDateTime timestampBefore, Pageable pageable);
}

================
File: src/main/java/com/backend/system/security/CustomUserDetails.java
================
package com.backend.system.security;

import com.backend.system.entity.User;
import lombok.AllArgsConstructor;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;


import java.util.Collection;
import java.util.List;

@AllArgsConstructor
@Getter
public class CustomUserDetails implements UserDetails {

    private User user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of();
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }
}

================
File: src/main/java/com/backend/system/security/CustomUserDetailsService.java
================
package com.backend.system.security;

import com.backend.system.entity.User;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.repository.UserRepository;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

@Component
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
public class CustomUserDetailsService implements UserDetailsService {

    UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.info("Loading user by username: {}", username);
        User user = userRepository.findUserByUsername(username)
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));
        return new CustomUserDetails(user);
    }
}

================
File: src/main/java/com/backend/system/security/JwtAuthenticationProvider.java
================
package com.backend.system.security;

import com.backend.system.exception.ErrorCode;
import com.backend.system.exception.InvalidTokenException;
import com.backend.system.exception.TokenExpiredException;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtAuthenticationProvider {

    @Value("${JWT_SECRET_KEY}")
    private String jwtSecretKey;

    @Value("${JWT_EXPIRATION}")
    private long expiration;

    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(jwtSecretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    private String buildToken(
            Map<String, Object> extractClaims,
            UserDetails userDetails,
            long expiration
    ) {
        return Jwts
                .builder()
                .setClaims(extractClaims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    public String generateToken(Map<String, Object> extractClaims, UserDetails userDetails) {
        return buildToken(extractClaims, userDetails, expiration);
    }

   public Claims extractAllClaims(String token) {
       try {
           return Jwts
                   .parserBuilder()
                   .setSigningKey(getSignInKey())
                   .build()
                   .parseClaimsJws(token)
                   .getBody();
       } catch (Exception e) {
           throw new InvalidTokenException(ErrorCode.INVALID_TOKEN);
       }
   }

    public <T> T extractClaims(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String extractUserName(String token) {
        return extractClaims(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaims(token, Claims::getExpiration);
    }

    public boolean isTokenValid(String token) {
        try {
            extractAllClaims(token);
            return true;
        } catch (InvalidTokenException e) {
            return false;
        }
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        String username = userDetails.getUsername();
        if (isTokenExpired(token))
            throw new TokenExpiredException(ErrorCode.TOKEN_EXPIRED);
        if (!extractUserName(token).equals(username))
            throw new InvalidTokenException(ErrorCode.INVALID_TOKEN);
        return true;
    }

    public boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date(System.currentTimeMillis()));
    }
}

================
File: src/main/java/com/backend/system/service/AuthService.java
================
package com.backend.system.service;

import com.backend.system.dto.request.AuthRequest;
import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.response.TokenResponse;
import com.backend.system.dto.response.UserResponse;
import org.springframework.security.core.userdetails.UserDetails;

public interface AuthService {
    TokenResponse login(AuthRequest authRequest);
    void register(AuthRequest authRequest);
    UserResponse getMe(UserDetails userDetails);
    String getRegistrationToken(UserDetails userDetails);
    void updateRegistrationToken(UserDetails userDetails, RegistrationTokenRequest registrationTokenRequest);
}

================
File: src/main/java/com/backend/system/service/CloudinaryService.java
================
package com.backend.system.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface CloudinaryService {
    String upload(MultipartFile file) throws IOException;
    String get(String publicId) throws Exception;
}

================
File: src/main/java/com/backend/system/service/FCMService.java
================
package com.backend.system.service;

import com.backend.system.entity.NoticeFCM;

public interface FCMService {
    void sendNotification(NoticeFCM noticeFCM);
}

================
File: src/main/java/com/backend/system/service/HistoryService.java
================
package com.backend.system.service;

import com.backend.system.dto.request.HistoryRequest;
import com.backend.system.dto.response.HistoryResponse;
import org.springframework.data.domain.Page;
import java.time.LocalDate;

public interface HistoryService {
     Page<HistoryResponse> getAll(int page, int limit, LocalDate start, LocalDate end);
     HistoryResponse getHistoryById(Long historyId);
     HistoryResponse addHistory(HistoryRequest historyRequest);
     HistoryResponse updateHistoryById(Long historyId, HistoryRequest historyRequest);
     void deleteHistoryById(Long historyId);
     Page<HistoryResponse> getHistoriesByPeopleId(Long peopleId, int page, int limit);
}

================
File: src/main/java/com/backend/system/service/impl/AuthServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.dto.request.AuthRequest;
import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.response.TokenResponse;
import com.backend.system.dto.response.UserResponse;
import com.backend.system.entity.User;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.UserMapper;
import com.backend.system.repository.UserRepository;
import com.backend.system.security.CustomUserDetails;
import com.backend.system.security.JwtAuthenticationProvider;
import com.backend.system.service.AuthService;
import com.backend.system.service.UserService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
@Slf4j
public class AuthServiceImpl implements AuthService {

    UserRepository userRepository;
    AuthenticationManager authenticationManager;
    JwtAuthenticationProvider jwtAuthenticationProvider;
    PasswordEncoder passwordEncoder;
    UserMapper userMapper;
    UserService userService;

    @Override
    public TokenResponse login(AuthRequest authRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            authRequest.getUsername(),
                            authRequest.getPassword()
                    ));

            CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();

            String token = jwtAuthenticationProvider.generateToken(userDetails);

            return TokenResponse.builder()
                    .token(token)
                    .tokenType("Bearer")
                    .expiration(jwtAuthenticationProvider.extractExpiration(token).getTime())
                    .build();
        } catch (Exception e) {
            log.error("Authentication failed for user: {}", authRequest.getUsername(), e);
            throw new AppException(ErrorCode.AUTHENTICATION_FAILED);
        }
    }

    @Override
    public void register(AuthRequest authRequest) {
        if (userRepository.findUserByUsername(authRequest.getUsername()).isPresent())
            throw new AppException(ErrorCode.USERNAME_ALREADY_EXISTS);
        User user = new User();
        user.setUsername(authRequest.getUsername());
        user.setPassword(passwordEncoder.encode(authRequest.getPassword()));
        userRepository.save(user);
    }

    @Override
    public UserResponse getMe(UserDetails userDetails) {
        return userMapper.toUserResponse(getUserInAuthentication(userDetails));
    }

    @Override
    public String getRegistrationToken(UserDetails userDetails) {
        User user = getUserInAuthentication(userDetails);
        return user.getRegistrationToken();
    }

    @Override
    public void updateRegistrationToken(UserDetails userDetails,
                                        RegistrationTokenRequest registrationTokenRequest) {
        User user = getUserInAuthentication(userDetails);
        userService.updateRegistrationTokenByUserId(user.getUserId(), registrationTokenRequest);
    }

    private User getUserInAuthentication(UserDetails userDetails) {
        return ((CustomUserDetails) userDetails).getUser();
    }
}

================
File: src/main/java/com/backend/system/service/impl/CloudinaryServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.service.CloudinaryService;
import com.cloudinary.Cloudinary;
import com.cloudinary.api.ApiResponse;
import com.cloudinary.utils.ObjectUtils;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.Map;
import java.util.UUID;


@Service
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class CloudinaryServiceImpl implements CloudinaryService {

    Cloudinary cloudinary;

    @Override
    public String upload(MultipartFile file) throws IOException {
        UUID uuid = UUID.randomUUID();
        Map params = ObjectUtils.asMap(
                "public_id", uuid.toString(),
                "use_filename", true,
                "unique_filename", false,
                "overwrite", true
        );

        Map result = cloudinary.uploader().upload(file.getBytes(), params);
        return (String) result.get("url");
    }

    @Override
    public String get(String publicId) throws Exception {
        ApiResponse apiResponse = cloudinary.api().resource(publicId, ObjectUtils.emptyMap());
        return (String) apiResponse.get("url");
    }
}

================
File: src/main/java/com/backend/system/service/impl/FCMServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.entity.NoticeFCM;
import com.backend.system.service.FCMService;
import com.google.api.core.ApiFuture;
import com.google.firebase.messaging.BatchResponse;
import com.google.firebase.messaging.FirebaseMessaging;
import com.google.firebase.messaging.MulticastMessage;
import com.google.firebase.messaging.Notification;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.ExecutionException;

@Slf4j
@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class FCMServiceImpl implements FCMService {

    FirebaseMessaging firebaseMessaging;

    @Override
    public void sendNotification(NoticeFCM noticeFCM) {
        List<String> registrationTokens = noticeFCM.getRegistrationTokens();
        Notification notification = Notification
                .builder()
                .setTitle(noticeFCM.getSubject())
                .setBody(noticeFCM.getContent())
                .setImage(noticeFCM.getImagePath())
                .build();

        MulticastMessage multicastMessage = MulticastMessage
                .builder()
                .addAllTokens(registrationTokens)
                .setNotification(notification)
                .putAllData(noticeFCM.getData())
                .build();

        ApiFuture<BatchResponse> apiFuture = firebaseMessaging.sendEachForMulticastAsync(multicastMessage);
        apiFuture.addListener(
                () -> {
                    try {
                        BatchResponse batchResponse = apiFuture.get();
                        log.info("Send notification success: {}", batchResponse.getSuccessCount());
                        log.warn("Send notification failure: {}", batchResponse.getFailureCount());
                    } catch (InterruptedException | ExecutionException e) {
                        log.error("Error sending FCM notification: {}", e.getMessage());
                    }
                }, Runnable::run
        );
    }
}

================
File: src/main/java/com/backend/system/service/impl/HistoryServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.dto.request.HistoryRequest;
import com.backend.system.dto.response.HistoryResponse;
import com.backend.system.entity.History;
import com.backend.system.entity.People;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.HistoryMapper;
import com.backend.system.repository.HistoryRepository;
import com.backend.system.service.HistoryService;
import com.backend.system.service.PeopleService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Optional;

@Service
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class HistoryServiceImpl implements HistoryService {

    HistoryRepository historyRepository;
    HistoryMapper historyMapper;
    PeopleService peopleService;

    private Page<History> getAll(Pageable pageable) {
        return historyRepository.findAll(pageable);
    }

    @Override
    public Page<HistoryResponse> getAll(int page, int limit, LocalDate start, LocalDate end) {
        Pageable pageable = PageRequest.of(page, limit);
        if (start == null || end == null) return getAll(pageable).map(historyMapper::toHistoryResponse);
        LocalDateTime startDate = start.atStartOfDay();
        LocalDateTime endDate = end.atTime(LocalTime.MAX);
        return historyRepository.findAllByTimestampAfterAndTimestampBefore(startDate, endDate, pageable)
                .map(historyMapper::toHistoryResponse);
    }

    @Override
    public HistoryResponse getHistoryById(Long historyId) {
        return historyMapper.toHistoryResponse(getHistoryEntityById(historyId));
    }

    @Override
    public HistoryResponse addHistory(HistoryRequest historyRequest) {
        Optional<People> optional = Optional.empty();
        if (historyRequest.getPeopleId() != null)
            optional = peopleService.getOptionalPeopleById(historyRequest.getPeopleId());
        History history = new History();
        history.setTimestamp(historyRequest.getTimestamp());
        history.setImagePath(historyRequest.getImagePath());
        history.setMode(historyRequest.getMode());
        optional.ifPresent(history::setPeople);
        return historyMapper.toHistoryResponse(historyRepository.save(history));
    }

    @Override
    public HistoryResponse updateHistoryById(Long historyId, HistoryRequest historyRequest) {
        History existingHistory = getHistoryEntityById(historyId);
        existingHistory.setTimestamp(historyRequest.getTimestamp());
        existingHistory.setImagePath(historyRequest.getImagePath());
        existingHistory.setMode(historyRequest.getMode());
        return historyMapper.toHistoryResponse(
                historyRepository.save(existingHistory)
        );
    }

    @Override
    public void deleteHistoryById(Long historyId) {
        History existingHistory = getHistoryEntityById(historyId);
        historyRepository.delete(existingHistory);
    }

    @Override
    public Page<HistoryResponse> getHistoriesByPeopleId(Long peopleId, int page, int limit) {
        Pageable pageable = PageRequest.of(page, page);
        People people = peopleService.getPeopleEntityById(peopleId);
        return historyRepository.findAllByPeople(people, pageable)
                .map(historyMapper::toHistoryResponse);

    }

    private History getHistoryEntityById(Long historyId) {
        return historyRepository.findById(historyId)
                .orElseThrow(() -> new AppException(ErrorCode.HISTORY_NOT_FOUND));
    }
}

================
File: src/main/java/com/backend/system/service/impl/NotificationServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.entity.Notification;
import com.backend.system.service.NotificationService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class NotificationServiceImpl implements NotificationService {

    SimpMessagingTemplate simpMessagingTemplate;

    @Override
    public void sendMessage(String destination, Notification notification) {
        simpMessagingTemplate.convertAndSend(destination, notification);
    }
}

================
File: src/main/java/com/backend/system/service/impl/PeopleServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.dto.request.PeopleRequest;
import com.backend.system.dto.response.PeopleResponse;
import com.backend.system.entity.People;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.PeopleMapper;
import com.backend.system.repository.PeopleRepository;
import com.backend.system.service.CloudinaryService;
import com.backend.system.service.PeopleService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class PeopleServiceImpl implements PeopleService {

    PeopleRepository peopleRepository;
    PeopleMapper peopleMapper;
    CloudinaryService cloudinaryService;

    @Override
    public Page<PeopleResponse> getAll(int page, int limit) {
        Pageable pageable = PageRequest.of(page, limit);
        Page<People> people = peopleRepository.findAll(pageable);
        return people.map(peopleMapper::toPeopleResponse);
    }

    @Override
    public PeopleResponse getPeopleDtoById(Long peopleId) {
        People people = getPeopleEntityById(peopleId);
        return peopleMapper.toPeopleResponse(people);
    }

    @Override
    public PeopleResponse addPeople(PeopleRequest peopleRequest) {
        try {
            People people = new People();
            people.setName(peopleRequest.getName());
            people.setAge(peopleRequest.getAge());
            people.setFaceImagePath(cloudinaryService.upload(peopleRequest.getFile()));
            return peopleMapper.toPeopleResponse(peopleRepository.save(people));
        } catch (IOException e) {
            log.error("Error uploading image to Cloudinary: {}", e.getMessage());
            throw new AppException(ErrorCode.IMAGE_UPLOAD_ERROR);
        }
    }

    @Override
    public PeopleResponse updatePeopleById(Long peopleId, PeopleRequest peopleRequest) {
        try {
            People existingPeople = getPeopleEntityById(peopleId);
            existingPeople.setName(peopleRequest.getName());
            if (peopleRequest.getAge() != 0) existingPeople.setAge(peopleRequest.getAge());
            if (peopleRequest.getFile() != null) existingPeople.setFaceImagePath(cloudinaryService.upload(peopleRequest.getFile()));
            return peopleMapper.toPeopleResponse(
                    peopleRepository.save(existingPeople)
            );
        } catch (IOException e) {
            log.error("Error uploading image to Cloudinary: {}", e.getMessage());
            throw new AppException(ErrorCode.IMAGE_UPLOAD_ERROR);
        }
    }

    @Override
    public void deletePeopleById(Long peopleId) {
        People people = getPeopleEntityById(peopleId);
        peopleRepository.delete(people);
    }

    @Override
    public Optional<People> getOptionalPeopleById(Long peopleId) {
        return peopleRepository.findById(peopleId);
    }

    @Override
    public People getPeopleEntityById(Long peopleId) {
        return peopleRepository.findById(peopleId)
                .orElseThrow(() -> new AppException(ErrorCode.PEOPLE_NOT_FOUND));
    }
}

================
File: src/main/java/com/backend/system/service/impl/PiServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.constant.ModeType;
import com.backend.system.dto.request.PiRequest;
import com.backend.system.dto.response.PiResponse;
import com.backend.system.entity.Notification;
import com.backend.system.entity.Pi;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.PiMapper;
import com.backend.system.repository.PiRepository;
import com.backend.system.service.NotificationService;
import com.backend.system.service.PiService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class PiServiceImpl implements PiService {

    PiRepository piRepository;
    PiMapper piMapper;
    NotificationService notificationService;

    @Override
    public List<PiResponse> getAll() {
        return piRepository.findAll()
                .stream()
                .map(piMapper::convertToPiResponse)
                .toList();
    }

    @Override
    public Pi getPiEntityById(Long piId) {
        return piRepository.findById(piId)
                .orElseThrow(() -> new AppException(ErrorCode.PI_NOT_FOUND));
    }

    @Override
    public PiResponse getPiById(Long piId) {
        return piMapper.convertToPiResponse(getPiEntityById(piId));
    }

    @Override
    public PiResponse addPi(PiRequest piRequest) {
        Pi pi = new Pi();
        pi.setDescription(piRequest.getDescription());
        pi.setMode(piRequest.getMode());
        return piMapper.convertToPiResponse(piRepository.save(pi));
    }

    @Override
    public PiResponse updatePiById(Long piId, PiRequest piRequest) {
        Pi pi = getPiEntityById(piId);
        pi.setDescription(piRequest.getDescription());
        pi.setMode(piRequest.getMode());
        return piMapper.convertToPiResponse(piRepository.save(pi));
    }

    @Override
    public PiResponse updateMode(Long piId, ModeType mode) {
        Pi pi = getPiEntityById(piId);
        pi.setMode(mode);
        pi = piRepository.save(pi);

        sendMessage(pi);

        System.out.println("Pi mode updated: " + pi.getMode());

        return piMapper.convertToPiResponse(pi);
    }

    @Override
    public void deletePiById(Long piId) {
        Pi pi = getPiEntityById(piId);
        piRepository.delete(pi);
    }

    private void sendMessage(Pi pi) {
        Notification<Pi> notification = Notification.<Pi>builder()
                .message("UPDATE_MODE")
                .data(pi)
                .build();

        System.out.println("Sending message: " + notification);

        notificationService.sendMessage("/topic/messages", notification);
    }
}

================
File: src/main/java/com/backend/system/service/impl/UserServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.request.UserRequest;

import com.backend.system.dto.response.RegistrationTokenResponse;
import com.backend.system.dto.response.UserResponse;
import com.backend.system.entity.People;
import com.backend.system.entity.User;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.UserMapper;
import com.backend.system.repository.UserRepository;
import com.backend.system.service.PeopleService;
import com.backend.system.service.UserService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;

@Service
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    UserRepository userRepository;
    UserMapper userMapper;
    PeopleService peopleService;
    PasswordEncoder passwordEncoder;

    @Override
    public List<UserResponse> getAll() {
        return userRepository.findAll()
                .stream()
                .map(userMapper::toUserResponse)
                .toList();

    }

    @Override
    public UserResponse getUserById(Long userId) {
        return userMapper.toUserResponse(getUserEntityById(userId));
    }

    @Override
    public UserResponse addUser(UserRequest userRequest) {
        if (userRepository.findUserByUsername(userRequest.getUsername()).isPresent()) {
            throw new AppException(ErrorCode.USERNAME_ALREADY_EXISTS);
        }

        People people = getPeopleIfSpecified(userRequest.getPeopleId());

        User user = new User();
        user.setUsername(userRequest.getUsername());
        user.setPassword(passwordEncoder.encode(userRequest.getPassword()));
        user.setPeople(people);

        return userMapper.toUserResponse(userRepository.save(user));
    }

    private People getPeopleIfSpecified(Long peopleId) {
        if (peopleId == null) {
            return null;
        }
        People people = peopleService.getOptionalPeopleById(peopleId)
                .orElse(null);
        if (people != null && userRepository.existsUserByPeople(people)) {
            throw new AppException(ErrorCode.PEOPLE_ALREADY_EXISTS);
        }
        return people;
    }

    @Override
    public UserResponse updateUserById(Long userId, UserRequest userRequest) {
        User existingUserById = getUserEntityById(userId);
        User existingUserByUserName = userRepository.findUserByUsername(userRequest.getUsername())
                .orElse(null);
        if (existingUserByUserName != null && !Objects.equals(existingUserByUserName.getUserId(), existingUserById.getUserId())) {
            throw new AppException(ErrorCode.USERNAME_ALREADY_EXISTS);
        }
        existingUserById.setUsername(userRequest.getUsername());
        existingUserById.setPassword(passwordEncoder.encode(userRequest.getPassword()));
        People people = peopleService.getPeopleEntityById(userRequest.getPeopleId());
        existingUserById.setPeople(people);
        return userMapper.toUserResponse(
                userRepository.save(existingUserById)
        );
    }

    @Override
    public void deleteUserById(Long userId) {
        User user = getUserEntityById(userId);
        userRepository.delete(user);
    }

    @Override
    public List<RegistrationTokenResponse> getAllRegistrationTokens() {
        return userRepository.findAllRegistrationToken()
                .stream()
                .map(RegistrationTokenResponse::new)
                .toList();
    }

    @Override
    public RegistrationTokenResponse getRegistrationTokenByUserId(Long userId) {
        User user = getUserEntityById(userId);
        return new RegistrationTokenResponse(user.getRegistrationToken());
    }

    @Override
    public void updateRegistrationTokenByUserId(Long userId, RegistrationTokenRequest registrationTokenRequest) {
        User user = getUserEntityById(userId);
        user.setRegistrationToken(registrationTokenRequest.getToken());
        userRepository.save(user);

    }

    private User getUserEntityById(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));
    }
}

================
File: src/main/java/com/backend/system/service/impl/WarningServiceImpl.java
================
package com.backend.system.service.impl;

import com.backend.system.entity.NoticeFCM;
import com.backend.system.dto.request.WarningRequest;
import com.backend.system.dto.response.RegistrationTokenResponse;
import com.backend.system.dto.response.WarningResponse;
import com.backend.system.entity.Warning;
import com.backend.system.exception.AppException;
import com.backend.system.exception.ErrorCode;
import com.backend.system.mapper.WarningMapper;
import com.backend.system.repository.WarningRepository;
import com.backend.system.service.FCMService;
import com.backend.system.service.UserService;
import com.backend.system.service.WarningService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;

@Service
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@RequiredArgsConstructor
public class WarningServiceImpl implements WarningService {

    WarningRepository warningRepository;
    FCMService fcmService;
    UserService userService;
    WarningMapper warningMapper;

    private Page<WarningResponse> getAll(Pageable pageable) {
        return warningRepository.findAll(pageable)
                .map(warningMapper::covertToWarningResponse);
    }

    @Override
    public Page<WarningResponse> getAll(int page, int limit, LocalDate start, LocalDate end) {
        Pageable pageable = PageRequest.of(page, limit);
        if (start == null || end == null) return getAll(pageable);
        LocalDateTime startDate = start.atStartOfDay();
        LocalDateTime endDate = end.atTime(LocalTime.MAX);
        return warningRepository.findAllByTimestampAfterAndTimestampBefore(startDate, endDate, pageable)
                .map(warningMapper::covertToWarningResponse);
    }

    @Override
    public WarningResponse getWarningById(Long warningId) {
        return warningMapper.covertToWarningResponse(getWarningEntityById(warningId));
    }

    @Override
    public Warning getWarningEntityById(Long warningId) {
        return warningRepository.findById(warningId)
                .orElseThrow(() -> new AppException(ErrorCode.WARNING_NOT_FOUND));
    }

    @Override
    public WarningResponse addWarning(WarningRequest warningRequest) {
        Warning warning = new Warning();
        warning.setTimestamp(warningRequest.getTimestamp());
        warning.setImagePath(warningRequest.getImagePath());
        warning.setInfo(warningRequest.getInfo());
        warning = warningRepository.save(warning);
        sendNotification(warning);
        return warningMapper.covertToWarningResponse(warning);
    }

    private void sendNotification(Warning warning) {
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

        List<String> tokens = userService.getAllRegistrationTokens()
                .stream()
                .map(RegistrationTokenResponse::getToken)
                .toList();

        Map<String, String> data = Map.of(
                "timestamp", warning.getTimestamp().format(dateTimeFormatter),
                "info", warning.getInfo(),
                "image", warning.getImagePath()
        );
        NoticeFCM noticeFCM = new NoticeFCM();
        noticeFCM.setSubject("");
        noticeFCM.setContent("");
        noticeFCM.setData(data);
        noticeFCM.setImagePath(warning.getImagePath());
        noticeFCM.setRegistrationTokens(tokens);

        fcmService.sendNotification(noticeFCM);
    }

    @Override
    public WarningResponse updateWarningById(Long warningId, WarningRequest warningRequest) {
        Warning existingWaring = getWarningEntityById(warningId);
        existingWaring.setTimestamp(warningRequest.getTimestamp());
        existingWaring.setImagePath(warningRequest.getImagePath());
        existingWaring.setInfo(warningRequest.getInfo());
        return warningMapper.covertToWarningResponse(warningRepository.save(existingWaring));
    }


    @Override
    public void deleteWarningById(Long warningId) {
        Warning existingWarning = getWarningEntityById(warningId);
        warningRepository.delete(existingWarning);
    }
}

================
File: src/main/java/com/backend/system/service/NotificationService.java
================
package com.backend.system.service;

import com.backend.system.entity.Notification;

public interface NotificationService {
    void sendMessage(String destination, Notification notification);
}

================
File: src/main/java/com/backend/system/service/PeopleService.java
================
package com.backend.system.service;

import com.backend.system.dto.request.PeopleRequest;
import com.backend.system.dto.response.PeopleResponse;
import com.backend.system.entity.People;
import org.springframework.data.domain.Page;

import java.util.Optional;

public interface PeopleService {
    Page<PeopleResponse> getAll(int page, int limit);
    PeopleResponse getPeopleDtoById(Long peopleId);
    PeopleResponse addPeople(PeopleRequest peopleRequest);
    PeopleResponse updatePeopleById(Long peopleId, PeopleRequest peopleRequest);
    void deletePeopleById(Long peopleId);
    Optional<People> getOptionalPeopleById(Long peopleId);
    People getPeopleEntityById(Long peopleId);
}

================
File: src/main/java/com/backend/system/service/PiService.java
================
package com.backend.system.service;

import com.backend.system.constant.ModeType;
import com.backend.system.dto.request.PiRequest;
import com.backend.system.dto.response.PiResponse;
import com.backend.system.entity.Pi;

import java.util.List;

public interface PiService {
    List<PiResponse> getAll();
    Pi getPiEntityById(Long piId);
    PiResponse getPiById(Long piId);
    PiResponse addPi(PiRequest piRequest);
    PiResponse updatePiById(Long piId, PiRequest piRequest);
    PiResponse updateMode(Long piId, ModeType mode);
    void deletePiById(Long piId);
}

================
File: src/main/java/com/backend/system/service/UserService.java
================
package com.backend.system.service;

import com.backend.system.dto.request.RegistrationTokenRequest;
import com.backend.system.dto.request.UserRequest;
import com.backend.system.dto.response.RegistrationTokenResponse;
import com.backend.system.dto.response.UserResponse;

import java.util.List;

public interface UserService {
    List<UserResponse> getAll();
    UserResponse getUserById(Long userId);
    UserResponse addUser(UserRequest userRequest);
    UserResponse updateUserById(Long userId, UserRequest userRequest);
    void deleteUserById(Long userId);
    List<RegistrationTokenResponse> getAllRegistrationTokens();
    RegistrationTokenResponse getRegistrationTokenByUserId(Long userId);
    void updateRegistrationTokenByUserId(Long userId, RegistrationTokenRequest registrationTokenRequest);
}

================
File: src/main/java/com/backend/system/service/WarningService.java
================
package com.backend.system.service;

import com.backend.system.dto.request.WarningRequest;
import com.backend.system.dto.response.WarningResponse;
import com.backend.system.entity.Warning;
import org.springframework.data.domain.Page;

import java.time.LocalDate;


public interface WarningService {
    Page<WarningResponse> getAll(int page, int limit, LocalDate start, LocalDate end);
    WarningResponse getWarningById(Long warningId);
    Warning getWarningEntityById(Long warningId);
    WarningResponse addWarning(WarningRequest warningRequest);
    WarningResponse updateWarningById(Long warningId, WarningRequest warningRequest);
    void deleteWarningById(Long warningId);
}

================
File: src/main/java/com/backend/system/SystemApplication.java
================
package com.backend.system;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableJpaAuditing
@EnableAsync
public class SystemApplication {

	public static void main(String[] args) {
		SpringApplication.run(SystemApplication.class, args);
	}

}

================
File: src/main/resources/application.properties
================
spring.application.name=system

================
File: src/main/resources/application.yaml
================
server:
  port: 8080
spring:
  config:
    import: optional:file:.env[.properties]
  datasource:
    url: ${DATASOURCE_URL}
    username: ${DATASOURCE_USERNAME}
    password: ${DATASOURCE_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
logging:
  level:
    root: info
    org:
      springframework: debug

firebase:
  credentials:
    path: classpath:firebase/firebase-service-account.json

================
File: src/test/java/com/backend/system/RabbitMQTest.java
================
package com.backend.system;

public class RabbitMQTest {
}

================
File: src/test/java/com/backend/system/SystemApplicationTests.java
================
package com.backend.system;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SystemApplicationTests {

	@Test
	void contextLoads() {
	}

}
